import {
    CodeBlockWriter,
    ImportDeclarationStructure,
    OptionalKind,
    Project,
    PropertySignatureStructure,
    SourceFile,
    StructureKind,
} from 'ts-morph';
import SimpleSchema, { SchemaDefinition } from 'simpl-schema';
import { SchemaMap } from './schema-map';
import { from } from 'rxjs';
import { tap } from 'rxjs/operators';

class TypeNotFoundError extends Error {
    constructor(public typeName: string) {
        super();
    }
}

// Type name might have been defined explicitly
type ExtendedSchemaDefinition = SchemaDefinition & { typeName?: string };

export class SchemaImport {
    private static readonly _tmpDir = './.tmp';
    private schemas: SchemaMap;

    constructor(private tsConfigFilePath: string) {}

    generateModel(outputFilePath: string) {
        const project = new Project({
            tsConfigFilePath: this.tsConfigFilePath,
        });

        const mapNameAndFile = this.getSchemaMapNameAndFile(project);

        if (!mapNameAndFile) {
            throw new Error(
                '----------------------------------------\n' +
                    'File containing a SchemaMap export: not found\n' +
                    '---------------------------------------------'
            );
        }

        const outputFile = project.createSourceFile(outputFilePath, '', {
            overwrite: true,
        });

        outputFile.addStatements((writer: CodeBlockWriter) => {
            writer.writeLine('// *************************************************************');
            writer.writeLine('//                Generated file: do not edit');
            writer.writeLine('// This file was generated by schema-to-types npm library');
            writer.writeLine('// More info: https://github.com/OlivierChirouze/schema-to-types');
            writer.writeLine('// *************************************************************');
            writer.blankLine();
        });

        // Import all the imports that exist in the original file, not related to simpl-schema
        const imports: (OptionalKind<ImportDeclarationStructure> & {
            source: SourceFile;
        })[] = mapNameAndFile.source
            .getImportDeclarations()
            .map((d) => ({
                namedImports: d
                    .getNamedImports()
                    .map((i) => i.getName())
                    .filter((s) => s !== 'SchemaMap'),
                moduleSpecifier:
                    './' +
                    outputFile
                        .getRelativePathTo(d.getModuleSpecifierSourceFile())
                        // TS2691: An import path cannot end with a '.ts' extension.
                        .replace(/\.ts$/, ''),
                source: d.getModuleSpecifierSourceFile(),
            }))
            .filter((i) => i.namedImports.length > 0);

        outputFile.addImportDeclarations(imports);

        const importPath = this.getImportPath(mapNameAndFile.source);

        const importSchemas = from(import(importPath));
        importSchemas
            .pipe(
                tap((importedModule) => {
                    this.schemas = importedModule[mapNameAndFile.name];

                    for (let typeName in this.schemas) {
                        const schema = this.schemas[typeName];
                        const classDeclaration = outputFile.addInterface({
                            name: typeName,
                        });

                        mapNameAndFile.source.getStructure();

                        classDeclaration.setIsExported(true);

                        const keys = schema.objectKeys('');
                        keys.forEach((key, i) => {
                            const declaration = this.getDeclaration(key, schema);
                            classDeclaration.addProperty(declaration);
                        });
                    }

                    outputFile.organizeImports();

                    outputFile.formatText();
                    outputFile.save();

                    console.log(`File saved: ${outputFile.getFilePath()}`);
                })
            )
            .subscribe(
                () => {},
                (error) => {
                    if (error.message && error.message.endsWith('"typeName" is not a supported property')) {
                        console.error(
                            '---------------------------------------------------------------------------------------------\n' +
                                "It seems you are using typeName property but didn't allow it. Make sure your schema file contains:\n" +
                                "SimpleSchema.extendOptions(['typeName']);\n" +
                                '--------------------------------------------------------------------------------------------------\n'
                        );
                    } else {
                        throw error;
                    }
                }
            );

        //const otherImports = imports.map(i => from(import(i.source.getFilePath())));
    }

    private getSchemaMapNameAndFile(project: Project): { name: string; source: SourceFile } | undefined {
        const files = project.getSourceFiles();
        for (let iFile = 0; iFile < files.length; iFile++) {
            let file = files[iFile];
            const statements = file.getStructure().statements as any[];
            for (let iStatement = 0; iStatement < statements.length; iStatement++) {
                let statement = statements[iStatement];
                if (
                    statement.kind === StructureKind.VariableStatement &&
                    statement.isExported &&
                    statement.declarations &&
                    statement.declarations.length > 0
                ) {
                    const schemaMap = statement.declarations.filter((declaration) => declaration.type === 'SchemaMap');
                    if (schemaMap.length === 1) {
                        return {
                            name: schemaMap[0].name,
                            source: file,
                        };
                    }
                }
            }
        }
        return undefined;
    }

    private getDeclaration(name: string, schema: SimpleSchema): OptionalKind<PropertySignatureStructure> | undefined {
        const schemaDefinition = schema.getDefinition(name) as ExtendedSchemaDefinition;

        const type = this.getType(schemaDefinition, name, schema);

        let declaration: OptionalKind<PropertySignatureStructure> = {
            name: name,
            type,
            hasQuestionToken:
                schemaDefinition.optional === true ||
                (schemaDefinition.optional !== false && schemaDefinition.optional()),
        };

        // TODO use label for comment
        // TODO use min max values for comment
        // TODO support inheritance of schemas
        // TODO use allowedValues to generate enum?

        return declaration;
    }

    private getType(
        schemaDefinition: ExtendedSchemaDefinition,
        name: string,
        schema: SimpleSchema
    ): string | undefined {
        const rawType = schemaDefinition.type[0].type;

        if (schemaDefinition.typeName) {
            return schemaDefinition.typeName;
        }

        if (rawType == Date) {
            return 'Date';
        }
        if (rawType == String) {
            return 'string';
        }
        if (rawType == Boolean) {
            return 'boolean';
        }
        if (rawType == Number || rawType == SimpleSchema.Integer) {
            return 'number';
        }
        if (rawType == Object) {
            const prefix = `${name}`;
            const subKeys = schema.objectKeys(prefix);

            // Sub model is detailed
            if (subKeys.length > 0) {
                const subDeclarations = subKeys.map((subKey) => {
                    const declaration = this.getDeclaration(`${prefix}.${subKey}`, schema);
                    return `${subKey}${declaration.hasQuestionToken ? '?' : ''}: ${declaration.type}`;
                });

                return `{${subDeclarations.join(',')}}`;
            }

            // Sub model is not detailed
            return 'Object';
        }
        if (rawType == Array) {
            const prefix = `${name}.$`;
            const subKeys = schema.objectKeys(prefix);

            // Sub model is detailed
            if (subKeys.length > 0) {
                const subDeclarations = subKeys.map((subKey) => {
                    const declaration = this.getDeclaration(`${prefix}.${subKey}`, schema);
                    return `${subKey}${declaration.hasQuestionToken ? '?' : ''}: ${declaration.type}`;
                });

                return `{${subDeclarations.join(',')}}[]`;
            }

            // Sub model is not detailed
            const subDeclaration = this.getDeclaration(prefix, schema);
            return `${subDeclaration.type}[]`;
        }

        // TODO support multiple rules SimpleSchema.oneOf()
        // TODO support Regexp

        // This is probably related to another schema

        try {
            return this.getTypeName(name, rawType);
        } catch (e) {
            if (e instanceof TypeNotFoundError) {
                // Let's say it's an enum
                return Object.values(rawType)
                    .map((v) => JSON.stringify(v))
                    .join(' | ');
            } else {
                throw e;
            }
        }
    }

    private getTypeName(name: string, typeDefinition: Object): string | undefined {
        for (let typeName in this.schemas) {
            const schema = this.schemas[typeName];
            if (typeDefinition === schema) {
                return typeName;
            }
        }

        throw new TypeNotFoundError(name);
    }

    private getImportPath(schemaFile: SourceFile): string {
        // TODO Very unefficient, but works
        const project = new Project({
            compilerOptions: { outDir: SchemaImport._tmpDir },
        });

        const copyFile = project.addSourceFileAtPath(schemaFile.getFilePath());
        project.emitSync();

        return copyFile.getEmitOutput().getOutputFiles()[0].getFilePath();
    }
}
